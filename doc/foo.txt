Installing WebFUI

Philosophy of WebFUI

The goal of WebFUI is to let you do client-side Web programming in ClojureScript without having to ever deal with the DOM. Instead, all DOM is generated in realtime from a global Clojure atom that contains all the state for the program. Additionally, you supply a single function called "render-all" that can take the state and generate "enhanced" HTML from it. The DOM is automatically and continuously kept in sync with this HTML by WebFUI. Your program is only responsible for providing the functions shown in red in the picture below:

These functions in red can be written 100% in the functional style, which is one of the benefits of WebFUI. The other benefit is that the data that controls the DOM is just "plain old data" that eases unit testing and debugging.

A Simple WebFUI App

Here is concrete example program using WebFUI. It displays two edit fields and displays the sum of the numbers entered into those fields as a result (try it here- Requires Chrome or Safari as of now)

(ns webfui-examples.add-two-numbers.core
  (:use [webfui.framework :only [launch-app]])
  (:use-macros [webfui.framework.macros :only [add-dom-watch]]))

(defn render-all [state]
  (let [{:keys [a b]} state]
    [:div [:input#a {:watch :watch :value a}]
     " plus "
     [:input#b {:watch :watch :value b}] 
     [:p " equals "]
     [:span (+ a b)]]))

(defn valid-integer [s] 
  (and (< (count s) 15) (re-matches #"^[0-9]+$" s)))

(add-dom-watch :watch [state new-element]
               (let [{:keys [value id]} (second new-element)]
                 (when (valid-integer value)
                   {id (js/parseInt value)})))

(launch-app (atom {:a 0 :b 0}) render-all)

How State Changes Make it to the DOM

We initialize a WebFUI app by calling "launch-app" and supplying the state and "render-all" function. In this example, the state consists only of the values in the edit fields named A and B. As you can see, the render-all functions is just a dead-simple function that takes the state as an argument and returns the HTML needed for the app (using the same syntax used by hiccup.)

How DOM Changes Make it to the State

This happens by attaching "DOM watchers" to the DOM. You can see These are different than javascript "on__" events in that they use a "Show, don't tell" design: They simply let you see the before & after of the HTML. There is nothing like an "Event Object" you find in traditional DOM events: Instead, your code can see the before/after of any changes to the DOM (such as from a user typing into an edit field) and respond.



